{
  "scanDate": "2025-05-31T16:15:59.451Z",
  "baseDirectory": "c:\\Users\\a.gulak\\Documents\\projects\\RandD\\toninch\\contracts\\FeeBank",
  "filesCount": 4,
  "files": [
    {
      "name": "FeeBank.tact",
      "relativePath": "FeeBank.tact",
      "content": "import \"@stdlib/deploy\";\r\nimport \"./UserDepositContract.tact\";\r\nimport \"./FeeBankMessages.tact\";\r\n\r\n// ==================== Helper functions ====================\r\n\r\n// Send tokens (native TON or Jettons)\r\nfun sendTokens(token: Slice, to: Slice, amount: Int, queryId: Int) {\r\n    if (token.bits() == 0) {\r\n        // Native TON transfer\r\n        send(SendParameters{to: to.asAddress(0), value: amount, mode: SendPayGasSeparately, body: beginCell().endCell()}\r\n        );\r\n    } else {\r\n        // Jetton transfer\r\n        send(SendParameters{\r\n                to: token.asAddress(0),\r\n                value: ton(\"0.05\"),\r\n                mode: SendPayGasSeparately,\r\n                body: beginCell().storeUint(0x0f8a7ea5,\r\n                    32 // transfer op\r\n                ).storeUint(queryId,\r\n                    64 // query_id\r\n                ).storeCoins(amount // amount\r\n                ).storeAddress(to.asAddress(0 // destination\r\n                    )\r\n                ).storeAddress(myAddress() // response_destination\r\n                ).storeBit(false // no custom_payload\r\n                ).storeCoins(1 // forward_ton_amount\r\n                ).storeBit(false // no forward_payload\r\n                ).endCell()\r\n            }\r\n        );\r\n    }\r\n}\r\n\r\n// ==================== FeeBank Main Contract ====================\r\n\r\ncontract FeeBank with Deployable {\r\n    feeToken: Slice;\r\n    charger: Slice;\r\n    owner: Slice;\r\n    // For tracking gatherFees operation\r\n    pendingFees: Int as uint256;\r\n    pendingGatherAccounts: map<Int, Address>;\r\n    pendingGatherCount: Int;\r\n    totalFeesCollected: Int as uint256;\r\n\r\n    inline fun onlyOwner() {\r\n        require(sender().asSlice() == self.owner, \"OnlyOwner\");\r\n    }\r\n\r\n    inline fun notifyCharger(body: Cell) {\r\n        send(SendParameters{to: self.charger.asAddress(0), value: ton(\"0.05\"), bounce: true, body: body});\r\n    }\r\n\r\n    fun queryCredit(account: Slice) {\r\n        self.notifyCharger(AvailCreditQuery{account: account, respondTo: null}.toCell());\r\n    }\r\n\r\n    fun userDepositContractInit(account: Slice): StateInit {\r\n        let initData = UserDepositInit{\r\n            parent: myAddress(),\r\n            account: account,\r\n            feeToken: self.feeToken,\r\n            charger: self.charger.asAddress(0)\r\n        };\r\n        return initOf UserDepositContract(initData);\r\n    }\r\n\r\n    fun userDepositAddress(account: Slice): Address {\r\n        return contractAddress(self.userDepositContractInit(account));\r\n    }\r\n\r\n    init(feeToken: Slice, charger: Slice, owner: Slice){\r\n        self.feeToken = feeToken;\r\n        self.charger = charger;\r\n        self.owner = owner;\r\n        self.pendingFees = 0;\r\n        self.pendingGatherAccounts = emptyMap();\r\n        self.pendingGatherCount = 0;\r\n        self.totalFeesCollected = 0;\r\n    }\r\n\r\n    // Query available credit for account\r\n    receive(msg: AvailCreditQueryRequest){\r\n        // Forward to charger with sender info\r\n        self.notifyCharger(AvailCreditQuery{account: msg.account, respondTo: sender()}.toCell());\r\n    }\r\n\r\n    // Handle native TON deposits\r\n    receive(msg: Deposit){\r\n        require(self.feeToken.bits() == 0, \"UseJettonTransfer\");\r\n        let amt: Int = context().value;\r\n        self._initiateDeposit(sender().asSlice(), amt);\r\n    }\r\n\r\n    receive(msg: DepositFor){\r\n        require(self.feeToken.bits() == 0, \"UseJettonTransfer\");\r\n        let amt: Int = context().value;\r\n        self._initiateDeposit(msg.account, amt);\r\n    }\r\n\r\n    // Handle Jetton deposits\r\n    receive(msg: JettonTransfer){\r\n        require(self.feeToken.bits() > 0, \"UseNativeDeposit\");\r\n        // Verify sender is the jetton wallet\r\n        require(sender().asSlice() == self.feeToken, \"InvalidJettonWallet\");\r\n        // Use response_destination as the depositor\r\n        self._initiateDeposit(msg.response_destination.asSlice(), msg.amount);\r\n    }\r\n\r\n    receive(msg: Withdraw){\r\n        self._initiateWithdraw(sender().asSlice(), sender().asSlice(), msg.amount);\r\n    }\r\n\r\n    receive(msg: WithdrawTo){\r\n        self._initiateWithdraw(sender().asSlice(), msg.account, msg.amount);\r\n    }\r\n\r\n    receive(msg: GatherFees){\r\n        self.onlyOwner();\r\n        // Reset gathering state\r\n        self.pendingGatherAccounts = emptyMap();\r\n        self.pendingGatherCount = 0;\r\n        self.pendingFees = 0;\r\n        // Parse accounts from Cell and store in map\r\n        let cs = msg.accounts.beginParse();\r\n        while (cs.refs() > 0) {\r\n            let accCell = cs.loadRef();\r\n            let accSlice = accCell.asSlice();\r\n            // Load address from slice\r\n            let accAddress = accSlice.loadAddress();\r\n            let accAddressSlice = beginCell().storeAddress(accAddress).endCell().asSlice();\r\n            // Store account address with its hash as key\r\n            self.pendingGatherAccounts.set(accAddressSlice.hash(), accAddress);\r\n            self.pendingGatherCount = self.pendingGatherCount + 1;\r\n            // Query credit for this account\r\n            self.queryCredit(accAddressSlice);\r\n        }\r\n    }\r\n\r\n    receive(msg: AvailCreditResp){\r\n        // This should come from charger\r\n        require(sender().asSlice() == self.charger, \"OnlyCharger\");\r\n        // Find the account in pending list\r\n        let accountHash = msg.account.hash();\r\n        let accountOpt = self.pendingGatherAccounts.get(accountHash);\r\n        if (accountOpt != null) {\r\n            // Send to user deposit contract to update\r\n            let userDepositAddr = self.userDepositAddress(msg.account);\r\n            send(SendParameters{\r\n                    to: userDepositAddr,\r\n                    value: ton(\"0.03\"),\r\n                    bounce: true,\r\n                    body: InternalGatherFee{creditNew: msg.credit}.toCell()\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    receive(msg: InternalFeeCollected){\r\n        // Verify sender is a valid user deposit contract\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        // Accumulate fees\r\n        self.pendingFees = self.pendingFees + msg.fee;\r\n        // Remove processed account and decrement counter\r\n        let accountHash = msg.account.hash();\r\n        if (self.pendingGatherAccounts.get(accountHash) != null) {\r\n            self.pendingGatherAccounts.del(accountHash);\r\n            self.pendingGatherCount = self.pendingGatherCount - 1;\r\n        }\r\n\r\n        // Check if we've processed all accounts\r\n        if (self.pendingGatherCount == 0 && self.pendingFees > 0) {\r\n            // All accounts processed, send collected fees to owner\r\n            self.totalFeesCollected = self.totalFeesCollected + self.pendingFees;\r\n            sendTokens(self.feeToken, self.owner, self.pendingFees, now());\r\n            self.pendingFees = 0;\r\n        }\r\n    }\r\n\r\n    receive(msg: InternalDepositSuccess){\r\n        // Verify sender and notify charger\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        self.notifyCharger(IncreaseCredit{account: msg.account, amount: msg.amount}.toCell());\r\n    }\r\n\r\n    receive(msg: InternalWithdrawSuccess){\r\n        // Verify sender and send tokens\r\n        let expectedAddr = self.userDepositAddress(msg.caller);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        sendTokens(self.feeToken, msg.target, msg.amount, 0);\r\n    }\r\n\r\n    // Handle responses from charger\r\n    receive(msg: IncreaseResp){\r\n        require(sender().asSlice() == self.charger, \"OnlyCharger\");\r\n        // Credit increase confirmed, nothing else to do\r\n    }\r\n\r\n    receive(msg: DecreaseResp){\r\n        require(sender().asSlice() == self.charger, \"OnlyCharger\");\r\n        // Credit decrease confirmed, withdrawal already processed\r\n    }\r\n\r\n    receive(msg: RescueFunds){\r\n        self.onlyOwner();\r\n        sendTokens(msg.token, self.owner, msg.amount, 0);\r\n    }\r\n\r\n    fun _initiateDeposit(account: Slice, amount: Int) {\r\n        require(amount > 0, \"ZeroAmount\");\r\n        // Get init for user deposit contract\r\n        let stateInit = self.userDepositContractInit(account);\r\n        let userDepositAddr = contractAddress(stateInit);\r\n        // Send deposit message to user contract\r\n        send(SendParameters{\r\n                to: userDepositAddr,\r\n                value: ton(\"0.05\"),\r\n                bounce: false,\r\n                body: InternalDeposit{amount: amount}.toCell(),\r\n                code: stateInit.code,\r\n                data: stateInit.data\r\n            }\r\n        );\r\n    }\r\n\r\n    fun _initiateWithdraw(caller: Slice, target: Slice, amount: Int) {\r\n        // First notify charger about decrease\r\n        self.notifyCharger(DecreaseCredit{account: caller, amount: amount}.toCell());\r\n        // Send withdraw request to user contract\r\n        let userDepositAddr = self.userDepositAddress(caller);\r\n        send(SendParameters{\r\n                to: userDepositAddr,\r\n                value: ton(\"0.03\"),\r\n                bounce: true,\r\n                body: InternalWithdraw{target: target, amount: amount}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Getters\r\n\r\n    get fun uerDeposit(account: Slice): Address {\r\n        return self.userDepositAddress(account);\r\n    }\r\n\r\n    get fun totalFeesCollected(): Int {\r\n        return self.totalFeesCollected;\r\n    }\r\n\r\n    get fun pendingGatherCount(): Int {\r\n        return self.pendingGatherCount;\r\n    }\r\n}"
    },
    {
      "name": "FeeBankCharger.tact",
      "relativePath": "FeeBankCharger.tact",
      "content": "import \"@stdlib/deploy\";\r\nimport \"./FeeBankMessages.tact\";\r\nimport \"./FeeBank.tact\";\r\nimport \"./UserDepositContract.tact\";\r\n\r\n// ==================== FeeBankCharger Contract ====================\r\n\r\ncontract FeeBankCharger with Deployable {\r\n    feeBank: Address;\r\n    feeToken: Slice;\r\n    owner: Address;\r\n    init(feeToken: Slice, owner: Address){\r\n        self.feeToken = feeToken;\r\n        self.owner = owner;\r\n        let feeBankInit = initOf FeeBank(feeToken, myAddress().asSlice(), owner.asSlice());\r\n        self.feeBank = contractAddress(feeBankInit);\r\n        send(SendParameters{\r\n                to: self.feeBank,\r\n                value: ton(\"0.1\"),\r\n                bounce: false,\r\n                body: Deploy{queryId: 0}.toCell(),\r\n                code: feeBankInit.code,\r\n                data: feeBankInit.data\r\n            }\r\n        );\r\n    }\r\n\r\n    // Only FeeBank can call these methods\r\n    inline fun onlyFeeBank() {\r\n        require(sender() == self.feeBank, \"OnlyFeeBankAccess\");\r\n    }\r\n\r\n    // Get user deposit contract address (same logic as FeeBank)\r\n\r\n    fun userDepositAddress(account: Slice): Address {\r\n        let initData = UserDepositInit{\r\n            parent: self.feeBank,\r\n            account: account,\r\n            feeToken: self.feeToken,\r\n            charger: myAddress()\r\n        };\r\n        return contractAddress(initOf UserDepositContract(initData));\r\n    }\r\n\r\n    // Handle credit increase request from FeeBank\r\n\r\n    receive(msg: IncreaseCredit){\r\n        self.onlyFeeBank();\r\n        // Forward to user's deposit contract\r\n        let userAddr = self.userDepositAddress(msg.account);\r\n        send(SendParameters{\r\n                to: userAddr,\r\n                value: ton(\"0.03\"),\r\n                bounce: true,\r\n                body: InternalIncreaseCredit{amount: msg.amount}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle response from user deposit contract\r\n    receive(msg: InternalCreditIncreased){\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        // Forward response to FeeBank\r\n        send(SendParameters{\r\n                to: self.feeBank,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: IncreaseResp{total: msg.total}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle credit decrease request from FeeBank\r\n    receive(msg: DecreaseCredit){\r\n        self.onlyFeeBank();\r\n        // Forward to user's deposit contract\r\n        let userAddr = self.userDepositAddress(msg.account);\r\n        send(SendParameters{\r\n                to: userAddr,\r\n                value: ton(\"0.03\"),\r\n                bounce: true,\r\n                body: InternalDecreaseCredit{amount: msg.amount}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle response from user deposit contract\r\n    receive(msg: InternalCreditDecreased){\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        // Forward response to FeeBank\r\n        send(SendParameters{\r\n                to: self.feeBank,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: DecreaseResp{total: msg.total}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle available credit query\r\n    receive(msg: AvailCreditQuery){\r\n        self.onlyFeeBank();\r\n        // Forward to user's deposit contract\r\n        let userAddr = self.userDepositAddress(msg.account);\r\n        send(SendParameters{\r\n                to: userAddr,\r\n                value: ton(\"0.03\"),\r\n                bounce: true,\r\n                body: InternalCreditQuery{respondTo: myAddress()}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle response from user deposit contract\r\n    receive(msg: InternalCreditResponse){\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        // Forward response to FeeBank\r\n        send(SendParameters{\r\n                to: self.feeBank,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: AvailCreditResp{credit: msg.credit, account: msg.account}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Charge fee from specific account (called by inheriting contracts)\r\n    fun _chargeFee(account: Slice, fee: Int) {\r\n        if (fee > 0) {\r\n            let userAddr = self.userDepositAddress(account);\r\n            send(SendParameters{\r\n                    to: userAddr,\r\n                    value: ton(\"0.03\"),\r\n                    bounce: true,\r\n                    body: InternalChargeFee{fee: fee}.toCell()\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // Handle fee charged response\r\n\r\n    receive(msg: InternalFeeCharged){\r\n        let expectedAddr = self.userDepositAddress(msg.account);\r\n        require(sender() == expectedAddr, \"InvalidUserContract\");\r\n        // Fee successfully charged, can emit event or process further\r\n    }\r\n\r\n    // Getter for available credit (queries user contract)\r\n    get fun availableCredit(account: Slice): Address {\r\n        // Returns user deposit contract address\r\n        // Actual credit should be queried from that contract\r\n        return self.userDepositAddress(account);\r\n    }\r\n\r\n    // Getter for FeeBank address\r\n\r\n    get fun feeBank(): Address {\r\n        return self.feeBank;\r\n    }\r\n}"
    },
    {
      "name": "FeeBankMessages.tact",
      "relativePath": "FeeBankMessages.tact",
      "content": "// Request to query available credit\r\nmessage(0xa7c9f823) AvailCreditQueryRequest {\r\n    account: Slice;\r\n} // ==================== Shared Messages for FeeBank System ====================\r\n// Messages between FeeBank and Charger\r\nmessage(0xb895f65f) IncreaseCredit {\r\n    account: Slice;\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x260ef7da) DecreaseCredit {\r\n    account: Slice;\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x15047436) AvailCreditQuery {\r\n    account: Slice;\r\n    respondTo: Address?; // Optional direct response address\r\n}\r\nmessage(0x5ee2eed5) AvailCreditResp {\r\n    credit: Int as uint256;\r\n    account: Slice; // Important for tracking responses\r\n}\r\nmessage(0x2a9b66f1) IncreaseResp {\r\n    total: Int as uint256;\r\n}\r\nmessage(0xe01e39a5) DecreaseResp {\r\n    total: Int as uint256;\r\n}\r\n// User messages to FeeBank\r\nmessage(0x4a25ce37) Deposit {\r\n}\r\nmessage(0x2666dfa5) DepositFor {\r\n    account: Slice;\r\n}\r\nmessage(0xd111285d) Withdraw {\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x5ccc41b3) WithdrawTo {\r\n    account: Slice;\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x1d591c7b) GatherFees {\r\n    accounts: Cell; // Cell containing list of accounts\r\n}\r\nmessage(0xd8d5619d) RescueFunds {\r\n    token: Slice;\r\n    amount: Int as uint256;\r\n}\r\n// Jetton Transfer message structure\r\nmessage(0x0f8a7ea5) JettonTransfer {\r\n    query_id: Int as uint64;\r\n    amount: Int as coins;\r\n    destination: Address;\r\n    response_destination: Address;\r\n    custom_payload: Cell?;\r\n    forward_ton_amount: Int as coins;\r\n    forward_payload: Slice as remaining;\r\n}\r\n// Internal messages between FeeBank and UserDepositContract\r\nmessage(0x3f4d39a6) InternalDeposit {\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x8e2c7b15) InternalWithdraw {\r\n    target: Slice;\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x9a4f2d81) InternalGatherFee {\r\n    creditNew: Int as uint256;\r\n}\r\nmessage(0x7c5e9f3a) InternalFeeCollected {\r\n    account: Slice;\r\n    fee: Int as uint256;\r\n}\r\nmessage(0xb2d4e837) InternalWithdrawSuccess {\r\n    caller: Slice;\r\n    target: Slice;\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x4e7f9c12) InternalDepositSuccess {\r\n    account: Slice;\r\n    amount: Int as uint256;\r\n}\r\n// Internal messages between Charger and UserDepositContract\r\nmessage(0xa3f7d218) InternalIncreaseCredit {\r\n    amount: Int as uint256;\r\n}\r\nmessage(0xc5e9b3f2) InternalDecreaseCredit {\r\n    amount: Int as uint256;\r\n}\r\nmessage(0x7d4a8c91) InternalCreditQuery {\r\n    respondTo: Address?;\r\n}\r\nmessage(0x8f3b2e5a) InternalCreditResponse {\r\n    account: Slice;\r\n    credit: Int as uint256;\r\n}\r\nmessage(0x2e7c9f4d) InternalChargeFee {\r\n    fee: Int as uint256;\r\n}\r\nmessage(0x9a5d3c7f) InternalCreditIncreased {\r\n    account: Slice;\r\n    total: Int as uint256;\r\n}\r\nmessage(0x4b8e2a91) InternalCreditDecreased {\r\n    account: Slice;\r\n    total: Int as uint256;\r\n}\r\nmessage(0x6f1e8b3c) InternalFeeCharged {\r\n    account: Slice;\r\n    fee: Int as uint256;\r\n    remaining: Int as uint256;\r\n}"
    },
    {
      "name": "UserDepositContract.tact",
      "relativePath": "UserDepositContract.tact",
      "content": "import \"./FeeBankMessages.tact\";\r\n// ==================== Init structure ====================\r\n\r\nstruct UserDepositInit {\r\n    parent: Address;\r\n    account: Slice;\r\n    feeToken: Slice;\r\n    charger: Address;\r\n}\r\n\r\n// ==================== UserDepositContract ====================\r\n\r\ncontract UserDepositContract {\r\n    parent: Address;\r\n    account: Slice;\r\n    feeToken: Slice;\r\n    charger: Address;\r\n    deposit: Int as uint256;\r\n    creditAllowance: Int as uint256;\r\n    init(initData: UserDepositInit){\r\n        self.parent = initData.parent;\r\n        self.account = initData.account;\r\n        self.feeToken = initData.feeToken;\r\n        self.charger = initData.charger;\r\n        self.deposit = 0;\r\n        self.creditAllowance = 0;\r\n    }\r\n\r\n    inline fun requireParent() {\r\n        require(sender() == self.parent, \"OnlyParent\");\r\n    }\r\n\r\n    inline fun requireCharger() {\r\n        require(sender() == self.charger, \"OnlyCharger\");\r\n    }\r\n\r\n    receive(msg: InternalDeposit){\r\n        self.requireParent();\r\n        self.deposit = self.deposit + msg.amount;\r\n        // Notify parent about successful deposit\r\n        send(SendParameters{\r\n                to: self.parent,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalDepositSuccess{account: self.account, amount: msg.amount}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    receive(msg: InternalWithdraw){\r\n        self.requireParent();\r\n        require(self.deposit >= msg.amount, \"InsufficientBalance\");\r\n        self.deposit = self.deposit - msg.amount;\r\n        // Notify parent about successful withdrawal\r\n        send(SendParameters{\r\n                to: self.parent,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalWithdrawSuccess{caller: self.account, target: msg.target, amount: msg.amount}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    receive(msg: InternalGatherFee){\r\n        self.requireParent();\r\n        let fee: Int = 0;\r\n        if (msg.creditNew < self.deposit) {\r\n            fee = self.deposit - msg.creditNew;\r\n            self.deposit = msg.creditNew;\r\n        }\r\n\r\n        // Send fee info back to parent\r\n        send(SendParameters{\r\n                to: self.parent,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalFeeCollected{account: self.account, fee: fee}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle credit increase from charger\r\n    receive(msg: InternalIncreaseCredit){\r\n        self.requireCharger();\r\n        self.creditAllowance = self.creditAllowance + msg.amount;\r\n        // Respond with new total\r\n        send(SendParameters{\r\n                to: self.charger,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalCreditIncreased{account: self.account, total: self.creditAllowance}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle credit decrease from charger\r\n    receive(msg: InternalDecreaseCredit){\r\n        self.requireCharger();\r\n        require(self.creditAllowance >= msg.amount, \"InsufficientCredit\");\r\n        self.creditAllowance = self.creditAllowance - msg.amount;\r\n        // Respond with new total\r\n        send(SendParameters{\r\n                to: self.charger,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalCreditDecreased{account: self.account, total: self.creditAllowance}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle credit query from charger\r\n    receive(msg: InternalCreditQuery){\r\n        self.requireCharger();\r\n        let respondTo = msg.respondTo;\r\n        if (respondTo == null) {\r\n            respondTo = self.charger;\r\n        }\r\n        send(SendParameters{\r\n                to: respondTo!!,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalCreditResponse{account: self.account, credit: self.creditAllowance}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Handle fee charge from charger\r\n    receive(msg: InternalChargeFee){\r\n        self.requireCharger();\r\n        require(self.creditAllowance >= msg.fee, \"NotEnoughCredit\");\r\n        self.creditAllowance = self.creditAllowance - msg.fee;\r\n        // Notify charger about successful charge\r\n        send(SendParameters{\r\n                to: self.charger,\r\n                value: 0,\r\n                mode: SendRemainingValue | SendIgnoreErrors,\r\n                body: InternalFeeCharged{account: self.account, fee: msg.fee, remaining: self.creditAllowance}.toCell()\r\n            }\r\n        );\r\n    }\r\n\r\n    // Getters\r\n    get fun getDeposit(): Int {\r\n        return self.deposit;\r\n    }\r\n\r\n    get fun getCreditAllowance(): Int {\r\n        return self.creditAllowance;\r\n    }\r\n\r\n    get fun getParent(): Address {\r\n        return self.parent;\r\n    }\r\n\r\n    get fun getCharger(): Address {\r\n        return self.charger;\r\n    }\r\n\r\n    get fun getAccount(): Slice {\r\n        return self.account;\r\n    }\r\n}"
    }
  ]
}